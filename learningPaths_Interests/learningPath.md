## Core interests
- How software **actually runs**
- Memory, execution, lifetime
- Debugging and correctness
- Low-level behavior
- Automation and tooling
- Avoiding heavy abstractions

This aligns best with **systems / infrastructure / runtime engineering**, with **security** as a later option.

---

## Phase 1 — Foundations (0–3 months)
**Learn**
- Python (tooling, automation)
- C (memory, control)
- OS basics (processes, threads, files)
- Debugging fundamentals

**Build**
- Python CLI tools
- Automation scripts
- Small C programs (allocate, crash, debug)

---

## Phase 2 — Systems tooling (3–6 months)
**Focus**
- Python + C together
- Performance awareness
- Reading/debugging real code

**Build**
- Developer tools
- Log analyzers
- Simple profilers or schedulers

---

## Phase 3 — Choose a direction (6–12 months)
Lightly explore:
- Infrastructure / Platform
- Runtime / Language internals
- Security fundamentals
- (Embedded only if hardware interests you)

Specialization comes **after exposure**, not before.

---

## What to build (portfolio)
- Automation tools
- Debugging helpers
- Performance utilities
- CLI tools engineers would actually use

---

## Career titles to target
- Systems Software Engineer
- Software Engineer – Infrastructure
- Platform Engineer
- Runtime Engineer
- Security Engineer (Systems)